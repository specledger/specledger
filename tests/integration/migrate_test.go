package integration

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"specledger/pkg/cli/metadata"
)

// TestMigrateModToYAML tests the sl migrate command
func TestMigrateModToYAML(t *testing.T) {
	tempDir := t.TempDir()
	slBinary := buildSLBinary(t, tempDir)

	// Create a test project with a legacy .mod file
	projectPath := filepath.Join(tempDir, "test-migrate-project")
	specledgerDir := filepath.Join(projectPath, "specledger")
	if err := os.MkdirAll(specledgerDir, 0755); err != nil {
		t.Fatalf("Failed to create project directory: %v", err)
	}

	// Create a legacy .mod file
	modPath := filepath.Join(specledgerDir, "specledger.mod")
	modContent := `# SpecLedger Dependency Manifest v1.0.0
# Generated by sl init on 2026-02-05
# Project: test-migrate-project
# Short Code: tmp
#
# To add dependencies, use:
#   sl deps add git@github.com:org/spec main spec.md --alias alias

# Dependencies are listed below (none yet)
`
	if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil {
		t.Fatalf("Failed to create .mod file: %v", err)
	}

	// Run sl migrate
	cmd := exec.Command(slBinary, "migrate")
	cmd.Dir = projectPath
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("sl migrate failed: %v\nOutput: %s", err, string(output))
	}

	outputStr := string(output)

	// Verify migration success message
	if !strings.Contains(outputStr, "Migration complete") && !strings.Contains(outputStr, "âœ“") {
		t.Errorf("Expected migration success message, got: %s", outputStr)
	}

	// Verify YAML file was created
	yamlPath := filepath.Join(projectPath, "specledger", "specledger.yaml")
	if _, err := os.Stat(yamlPath); os.IsNotExist(err) {
		t.Error("specledger.yaml was not created")
	}

	// Verify YAML content
	meta, err := metadata.Load(yamlPath)
	if err != nil {
		t.Fatalf("Failed to load migrated YAML: %v", err)
	}

	if meta.Project.Name != "test-migrate-project" {
		t.Errorf("Expected project name 'test-migrate-project', got '%s'", meta.Project.Name)
	}

	if meta.Project.ShortCode != "tmp" {
		t.Errorf("Expected short code 'tmp', got '%s'", meta.Project.ShortCode)
	}

	// Migrated projects should have specledger playbook
	if meta.Playbook.Name != "specledger" {
		t.Errorf("Expected playbook 'specledger' for migrated project, got '%s'", meta.Playbook.Name)
	}

	// Verify .mod file was backed up
	backupPath := filepath.Join(projectPath, "specledger", "specledger.spec.mod.backup")
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		t.Error("Backup .mod file was not created")
	}

	// Verify original .mod was moved
	if _, err := os.Stat(modPath); err == nil {
		t.Error("Original .mod file should have been moved/renamed")
	}
}

// TestMigrateDryRun tests the --dry-run flag
func TestMigrateDryRun(t *testing.T) {
	tempDir := t.TempDir()
	slBinary := buildSLBinary(t, tempDir)

	// Create a test project with a .mod file
	projectPath := filepath.Join(tempDir, "test-dryrun-project")
	specledgerDir := filepath.Join(projectPath, "specledger")
	if err := os.MkdirAll(specledgerDir, 0755); err != nil {
		t.Fatalf("Failed to create project directory: %v", err)
	}

	modPath := filepath.Join(specledgerDir, "specledger.mod")
	modContent := `# SpecLedger Dependency Manifest v1.0.0
# Project: test-dryrun-project
# Short Code: tdr
`
	if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil {
		t.Fatalf("Failed to create .mod file: %v", err)
	}

	// Run sl migrate --dry-run
	cmd := exec.Command(slBinary, "migrate", "--dry-run")
	cmd.Dir = projectPath
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Fatalf("sl migrate --dry-run failed: %v\nOutput: %s", err, string(output))
	}

	outputStr := string(output)

	// Verify dry-run output
	if !strings.Contains(outputStr, "Dry Run") && !strings.Contains(outputStr, "Dry run") {
		t.Error("Expected 'Dry Run' in output")
	}

	// Verify YAML was NOT created
	yamlPath := filepath.Join(projectPath, "specledger", "specledger.yaml")
	if _, err := os.Stat(yamlPath); !os.IsNotExist(err) {
		t.Error("YAML file should not be created in dry-run mode")
	}

	// Verify .mod file still exists
	if _, err := os.Stat(modPath); os.IsNotExist(err) {
		t.Error("Original .mod file should not be modified in dry-run mode")
	}
}

// TestMigrateNoModFile tests error handling when no .mod file exists
func TestMigrateNoModFile(t *testing.T) {
	tempDir := t.TempDir()
	slBinary := buildSLBinary(t, tempDir)

	// Create a project without a .mod file
	projectPath := filepath.Join(tempDir, "test-no-mod-project")
	if err := os.MkdirAll(projectPath, 0755); err != nil {
		t.Fatalf("Failed to create project directory: %v", err)
	}

	// Run sl migrate (should fail)
	cmd := exec.Command(slBinary, "migrate")
	cmd.Dir = projectPath
	output, err := cmd.CombinedOutput()

	if err == nil {
		t.Error("Expected sl migrate to fail when no .mod file exists")
	}

	outputStr := string(output)
	if !strings.Contains(outputStr, "no specledger.mod file found") && !strings.Contains(outputStr, "no .mod file") {
		t.Logf("Expected error message about missing .mod file, got: %s", outputStr)
	}
}

// TestMigrateAlreadyMigrated tests error when YAML already exists
func TestMigrateAlreadyMigrated(t *testing.T) {
	tempDir := t.TempDir()
	slBinary := buildSLBinary(t, tempDir)

	// Create a project with both .mod and .yaml files
	projectPath := filepath.Join(tempDir, "test-already-migrated")
	specledgerDir := filepath.Join(projectPath, "specledger")
	if err := os.MkdirAll(specledgerDir, 0755); err != nil {
		t.Fatalf("Failed to create project directory: %v", err)
	}

	// Create .mod file
	modPath := filepath.Join(specledgerDir, "specledger.mod")
	modContent := `# Project: test-already-migrated
# Short Code: tam
`
	if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil {
		t.Fatalf("Failed to create .mod file: %v", err)
	}

	// Create YAML file (simulating already migrated)
	yamlPath := filepath.Join(specledgerDir, "specledger.yaml")
	meta := metadata.NewProjectMetadata("test-already-migrated", "tam", "specledger", "1.0.0", []string{})
	if err := metadata.Save(meta, yamlPath); err != nil {
		t.Fatalf("Failed to create YAML file: %v", err)
	}

	// Run sl migrate (should fail or warn)
	cmd := exec.Command(slBinary, "migrate")
	cmd.Dir = projectPath
	output, err := cmd.CombinedOutput()

	outputStr := string(output)
	if err == nil {
		t.Error("Expected sl migrate to fail when YAML already exists")
	}

	if !strings.Contains(outputStr, "already exists") && !strings.Contains(outputStr, "not needed") {
		t.Logf("Expected warning about existing YAML, got: %s", outputStr)
	}
}

// TestMigrateInvalidModFile tests error handling for malformed .mod files
func TestMigrateInvalidModFile(t *testing.T) {
	tempDir := t.TempDir()
	slBinary := buildSLBinary(t, tempDir)

	// Create a project with an invalid .mod file
	projectPath := filepath.Join(tempDir, "test-invalid-mod")
	specledgerDir := filepath.Join(projectPath, "specledger")
	if err := os.MkdirAll(specledgerDir, 0755); err != nil {
		t.Fatalf("Failed to create project directory: %v", err)
	}

	// Create .mod file missing required fields
	modPath := filepath.Join(specledgerDir, "specledger.mod")
	modContent := `# This .mod file is missing project name and short code
# Just some comments here
`
	if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil {
		t.Fatalf("Failed to create .mod file: %v", err)
	}

	// Run sl migrate (should fail)
	cmd := exec.Command(slBinary, "migrate")
	cmd.Dir = projectPath
	output, err := cmd.CombinedOutput()

	if err == nil {
		t.Error("Expected sl migrate to fail with invalid .mod file")
	}

	outputStr := string(output)
	if !strings.Contains(strings.ToLower(outputStr), "could not find") &&
		!strings.Contains(strings.ToLower(outputStr), "failed to parse") {
		t.Logf("Expected error about missing fields, got: %s", outputStr)
	}
}

// TestYAMLMetadataBackwardCompatibility tests that new code can still handle .mod files
func TestYAMLMetadataBackwardCompatibility(t *testing.T) {
	// This test verifies that metadata loading functions can handle legacy .mod files
	tempDir := t.TempDir()

	// Create a .mod file
	projectPath := filepath.Join(tempDir, "test-compat")
	specledgerDir := filepath.Join(projectPath, "specledger")
	if err := os.MkdirAll(specledgerDir, 0755); err != nil {
		t.Fatalf("Failed to create project directory: %v", err)
	}

	modPath := filepath.Join(specledgerDir, "specledger.mod")
	modContent := `# Project: test-compat
# Short Code: tc
`
	if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil {
		t.Fatalf("Failed to create .mod file: %v", err)
	}

	// Verify HasLegacyModFile works
	if !metadata.HasLegacyModFile(projectPath) {
		t.Error("HasLegacyModFile should return true for .mod file")
	}

	// Verify HasYAMLMetadata returns false
	if metadata.HasYAMLMetadata(projectPath) {
		t.Error("HasYAMLMetadata should return false when only .mod exists")
	}

	// Parse the .mod file
	modData, err := metadata.ParseModFile(modPath)
	if err != nil {
		t.Fatalf("Failed to parse .mod file: %v", err)
	}

	if modData.ProjectName != "test-compat" {
		t.Errorf("Expected project name 'test-compat', got '%s'", modData.ProjectName)
	}

	if modData.ShortCode != "tc" {
		t.Errorf("Expected short code 'tc', got '%s'", modData.ShortCode)
	}
}
