package metadata

import (
	"os"
	"path/filepath"
	"testing"
)

func TestParseModFile(t *testing.T) {
	// Create temporary directory
	tmpDir, err := os.MkdirTemp("", "specledger-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create test .mod file
	modContent := `# SpecLedger Dependency Manifest v1.0.0
# Generated by sl init on 2026-02-05
# Project: test-project
# Short Code: tp
#
# To add dependencies, use:
#   sl deps add git@github.com:org/spec main spec.md --alias alias

# Dependencies are listed below (none yet)
`
	modPath := filepath.Join(tmpDir, "specledger.mod")
	if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil {
		t.Fatalf("failed to write test .mod file: %v", err)
	}

	// Parse the file
	metadata, err := ParseModFile(modPath)
	if err != nil {
		t.Fatalf("failed to parse .mod file: %v", err)
	}

	// Verify parsed data
	if metadata.ProjectName != "test-project" {
		t.Errorf("expected project name 'test-project', got '%s'", metadata.ProjectName)
	}

	if metadata.ShortCode != "tp" {
		t.Errorf("expected short code 'tp', got '%s'", metadata.ShortCode)
	}

	if metadata.CreatedAt.IsZero() {
		t.Error("expected CreatedAt to be set from file modification time")
	}
}

func TestParseModFileMissingFields(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "specledger-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	tests := []struct {
		name    string
		content string
		wantErr bool
	}{
		{
			"missing project name",
			"# Short Code: tp\n",
			true,
		},
		{
			"missing short code",
			"# Project: test\n",
			true,
		},
		{
			"both fields present",
			"# Project: test\n# Short Code: tp\n",
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			modPath := filepath.Join(tmpDir, tt.name+".mod")
			if err := os.WriteFile(modPath, []byte(tt.content), 0644); err != nil {
				t.Fatalf("failed to write test file: %v", err)
			}

			_, err := ParseModFile(modPath)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseModFile() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestMigrateModToYAML(t *testing.T) {
	// Create temporary directory
	tmpDir, err := os.MkdirTemp("", "specledger-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create specledger subdirectory
	specledgerDir := filepath.Join(tmpDir, "specledger")
	if err := os.MkdirAll(specledgerDir, 0755); err != nil {
		t.Fatalf("failed to create specledger dir: %v", err)
	}

	// Create test .mod file
	modContent := `# SpecLedger Dependency Manifest v1.0.0
# Project: migration-test
# Short Code: mt
`
	modPath := filepath.Join(specledgerDir, "specledger.mod")
	if err := os.WriteFile(modPath, []byte(modContent), 0644); err != nil {
		t.Fatalf("failed to write test .mod file: %v", err)
	}

	// Perform migration
	metadata, err := MigrateModToYAML(tmpDir)
	if err != nil {
		t.Fatalf("failed to migrate: %v", err)
	}

	// Verify metadata
	if metadata.Project.Name != "migration-test" {
		t.Errorf("expected name 'migration-test', got '%s'", metadata.Project.Name)
	}

	if metadata.Project.ShortCode != "mt" {
		t.Errorf("expected short code 'mt', got '%s'", metadata.Project.ShortCode)
	}

	if metadata.Playbook.Name != "specledger" {
		t.Errorf("expected playbook 'specledger', got '%s'", metadata.Playbook.Name)
	}

	if metadata.Project.Version != "0.1.0" {
		t.Errorf("expected version '0.1.0', got '%s'", metadata.Project.Version)
	}

	// Verify YAML file was created
	yamlPath := filepath.Join(tmpDir, DefaultMetadataFile)
	if _, err := os.Stat(yamlPath); os.IsNotExist(err) {
		t.Fatal("YAML file was not created")
	}

	// Verify .mod file still exists (should not be deleted)
	if _, err := os.Stat(modPath); os.IsNotExist(err) {
		t.Fatal(".mod file was deleted (should be preserved)")
	}

	// Verify we can load the YAML
	loaded, err := LoadFromProject(tmpDir)
	if err != nil {
		t.Fatalf("failed to load migrated YAML: %v", err)
	}

	if loaded.Project.Name != metadata.Project.Name {
		t.Error("loaded metadata does not match migrated metadata")
	}
}

func TestMigrateModToYAMLNoModFile(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "specledger-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	_, err = MigrateModToYAML(tmpDir)
	if err == nil {
		t.Error("expected error when no .mod file exists, got nil")
	}
}

func TestMigrateModToYAMLAlreadyMigrated(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "specledger-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create both .mod and .yaml files
	specledgerDir := filepath.Join(tmpDir, "specledger")
	if err := os.MkdirAll(specledgerDir, 0755); err != nil {
		t.Fatalf("failed to create specledger dir: %v", err)
	}

	modPath := filepath.Join(specledgerDir, "specledger.mod")
	if err := os.WriteFile(modPath, []byte("# Project: test\n# Short Code: ts\n"), 0644); err != nil {
		t.Fatalf("failed to write .mod file: %v", err)
	}

	metadata := NewProjectMetadata("test", "ts", "specledger", "1.0.0", []string{})
	if err := SaveToProject(metadata, tmpDir); err != nil {
		t.Fatalf("failed to create YAML file: %v", err)
	}

	// Attempt migration
	_, err = MigrateModToYAML(tmpDir)
	if err == nil {
		t.Error("expected error when YAML already exists, got nil")
	}
}

func TestHasLegacyModFile(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "specledger-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Initially should not have .mod file
	if HasLegacyModFile(tmpDir) {
		t.Error("expected HasLegacyModFile to return false when no file exists")
	}

	// Create .mod file
	specledgerDir := filepath.Join(tmpDir, "specledger")
	if err := os.MkdirAll(specledgerDir, 0755); err != nil {
		t.Fatalf("failed to create specledger dir: %v", err)
	}

	modPath := filepath.Join(specledgerDir, "specledger.mod")
	if err := os.WriteFile(modPath, []byte("# Project: test\n# Short Code: ts\n"), 0644); err != nil {
		t.Fatalf("failed to write .mod file: %v", err)
	}

	// Now should have .mod file
	if !HasLegacyModFile(tmpDir) {
		t.Error("expected HasLegacyModFile to return true when file exists")
	}
}

func TestHasYAMLMetadata(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "specledger-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Initially should not have YAML
	if HasYAMLMetadata(tmpDir) {
		t.Error("expected HasYAMLMetadata to return false when no file exists")
	}

	// Create YAML file
	metadata := NewProjectMetadata("test", "ts", "specledger", "1.0.0", []string{})
	if err := SaveToProject(metadata, tmpDir); err != nil {
		t.Fatalf("failed to save metadata: %v", err)
	}

	// Now should have YAML
	if !HasYAMLMetadata(tmpDir) {
		t.Error("expected HasYAMLMetadata to return true when file exists")
	}
}
