# Implementation Plan: SDD Workflow Streamline

**Branch**: `598-sdd-workflow-streamline` | **Date**: 2026-03-01 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `specledger/598-sdd-workflow-streamline/spec.md`

## Summary

Streamline the SDD workflow across two work streams:

1. **Comment CRUD** (US11, US14): Extract comment data operations from the monolithic `sl revise` command into a standalone `sl comment` CLI (Data CRUD pattern). Refactor `sl revise` into a clean launcher. Create `sl-comment` skill. Update `/specledger.clarify` to use `sl comment` instead of `sl revise --summary`.

2. **Bash Script Replacement** (US13, US16): Replace 6 bash scripts in `.specledger/scripts/bash/` with 4 Go CLI commands (`sl spec info`, `sl spec create`, `sl spec setup-plan`, `sl context update`). Eliminates `jq`/`bash` dependencies for cross-platform support.

Both streams are independent and can be implemented in parallel.

**Cross-cutting principle (D21)**: All `sl` CLI commands MUST produce token-efficient output. List commands default to compact overviews (truncated previews, counts instead of nested data). Detail commands (`show`) provide full content on demand. Every truncated output includes a follow-up hint for agents. See contracts for specifics.

## Technical Context

**Language/Version**: Go 1.24.2
**Primary Dependencies**: Cobra (CLI), go-git v5 (git), Bubble Tea + Bubbles + Lipgloss (TUI), YAML v3 (config)
**Storage**: Supabase PostgREST (review_comments table), file-based (JSONL for issues, YAML for config)
**Testing**: `go test` with table-driven tests, golden files for prompt snapshots
**Target Platform**: macOS, Linux, Windows (cross-platform — CLI constitution D16)
**Project Type**: CLI tool (single binary)
**Performance Goals**: All `sl comment` and `sl spec` commands complete in <2s (network-dependent for API calls)
**Constraints**: Offline-capable for spec/context commands; auth-required for comment API; no PTY requirement for any new command
**Scale/Scope**: ~8 new Go files, ~1500 LOC new code, ~500 LOC refactored from existing revise package

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- [x] **Specification-First**: Spec.md complete with 16 prioritized user stories (US1-US16) and acceptance scenarios
- [x] **Test-First**: Contract tests for PostgREST client, unit tests for branch naming/stop words, golden file tests for output formats
- [x] **Code Quality**: golangci-lint with govet, staticcheck, errcheck, ineffassign, unused, gosec
- [x] **UX Consistency**: CLI patterns follow Data CRUD (D16), human + JSON output modes, consistent flag naming
- [x] **Performance**: <2s target for all commands (network RTT dominates for API calls)
- [x] **Observability**: Errors to stderr, structured JSON output for machine consumption, `--verbose` flag for debug
- [x] **Issue Tracking**: Issues tracked via `sl issue` for spec 598-sdd-workflow-streamline

**Complexity Violations**: None. Both work streams follow established patterns already in the codebase.

## Project Structure

### Documentation (this feature)

```text
specledger/598-sdd-workflow-streamline/
├── plan.md                     # This file
├── research.md                 # Supabase schema, bash script analysis, architecture decisions
├── data-model.md               # Go type definitions for comment + spec entities
├── quickstart.md               # Test commands for validation
├── contracts/
│   ├── sl-comment-cli.md       # sl comment CLI contract
│   └── sl-spec-cli.md          # sl spec + sl context CLI contract
└── tasks.md                    # Generated by /specledger.tasks
```

### Source Code (repository root)

```text
pkg/cli/comment/                 # NEW — Comment CRUD package (extracted from revise)
├── types.go                     # ReviewComment, CommentThread, output types
├── client.go                    # PostgREST client (project→spec→change→comments chain)
└── client_test.go               # Unit tests for client operations

pkg/cli/commands/
├── comment.go                   # NEW — sl comment CLI command (list/show/reply/resolve)
├── spec.go                      # NEW — sl spec CLI command (info/create/setup-plan)
├── context.go                   # NEW — sl context CLI command (update)
└── revise.go                    # MODIFIED — simplified launcher, delegates to comment package

pkg/cli/revise/                  # MODIFIED — revise-specific logic only
├── types.go                     # MODIFIED — remove comment types (moved to comment/)
├── client.go                    # MODIFIED — remove comment client (moved to comment/)
├── prompt.go                    # Unchanged — prompt rendering stays revise-specific
├── editor.go                    # Unchanged — editor integration stays revise-specific
├── automation.go                # Unchanged — fixture support stays revise-specific
└── automation_test.go           # Unchanged

pkg/cli/spec/                    # NEW — Feature spec management package
├── types.go                     # FeatureInfo, FeatureCreateResult, PlanSetupResult
├── info.go                      # Prerequisite validation (replaces check-prerequisites.sh)
├── create.go                    # Feature creation (replaces create-new-feature.sh)
├── plan_setup.go                # Plan template copy (replaces setup-plan.sh)
├── branch_name.go               # Branch name generation, stop words, collision check
└── branch_name_test.go          # Tests for stop words, collision, GitHub limit

pkg/cli/context/                 # NEW — Agent context management package
├── types.go                     # PlanMetadata, AgentFileMapping, UpdateResult
├── update.go                    # Plan parsing + agent file update logic
├── mappings.go                  # Agent type → file path mappings (17+ agents)
└── update_test.go               # Tests for plan parsing, marker preservation

pkg/embedded/skills/             # MODIFIED
└── sl-comment.md                # NEW — sl-comment skill (teaches agent sl comment usage)

.claude/commands/
└── specledger.clarify.md        # MODIFIED — replace sl revise --summary with sl comment list
```

**Structure Decision**: Follows existing Go project layout. New packages (`comment/`, `spec/`, `context/`) mirror established patterns from `revise/`, `issues/`, `auth/`. Each package owns its domain logic; CLI commands in `commands/` are thin wrappers.

## Previous Work

### From 136-revise-comments
- PostgREST client with auth retry (`pkg/cli/revise/client.go`) — extract to `pkg/cli/comment/`
- Comment types (`pkg/cli/revise/types.go`) — extract to `pkg/cli/comment/`
- Agent launcher pattern (`pkg/cli/launcher/`) — reuse as-is
- Git helpers (`pkg/cli/git/`) — reuse for spec create branch operations
- Auth/credentials (`pkg/cli/auth/`) — reuse for comment API auth

### From 597-agent-model-config
- Config merge and environment injection — pattern for `sl context update`
- `BuildEnv()` in launcher — no changes needed

### From 596-doctor-version-update
- Template diff and update logic (`pkg/templates/`) — reference for `sl doctor --template` stale detection
- Template version tracking — reuse patterns

### From 591-issue-tracking-upgrade
- `ContextDetector` in `internal/ref/` — reuse for `sl spec info` branch resolution
- JSONL store patterns — reference only (comments use Supabase, not JSONL)

## Work Stream Breakdown

### Stream 1: Comment CRUD + Revise Refactor (US11, US14)

**Phase 1: Extract comment package**
1. Create `pkg/cli/comment/types.go` — move `ReviewComment`, `ThreadReply` from `pkg/cli/revise/types.go`
2. Create `pkg/cli/comment/client.go` — move PostgREST client from `pkg/cli/revise/client.go`
3. Add `CreateReply()` method (POST to PostgREST)
4. Update `pkg/cli/revise/` to import from `pkg/cli/comment/`
5. Verify `sl revise` still works unchanged

**Phase 2: Implement `sl comment` CLI**
1. Create `pkg/cli/commands/comment.go` with subcommands: list, show, reply, resolve
2. Wire `sl comment` into `cmd/sl/main.go`
3. Implement `list` with **compact output** (D21): truncated previews, reply counts, follow-up hints
4. Implement `show` with **full output**: complete content, full thread replies, action hints
5. `show` accepts multiple IDs for batch drill-down
6. Implement `--json` output matching contract (compact for list, full for show)
7. Implement `--status` filter (open/resolved/all)

**Phase 3: Create `sl-comment` skill**
1. Create `pkg/embedded/skills/sl-comment.md` following `sl-issue-tracking` pattern
2. Content: when to use `sl comment`, usage patterns, JSON parsing tips

**Phase 4: Update clarify command (high level)**
1. Replace `sl revise --summary` with `sl comment list --status open --json` in `specledger.clarify.md`
2. Add instructions for `sl comment reply` and `sl comment resolve` after addressing each comment
3. Reference `sl-comment` skill for progressive loading

### Stream 2: Bash Script Replacement (US13, US16)

**Phase 1: Core infrastructure**
1. Create `pkg/cli/spec/types.go` — FeatureInfo, FeatureCreateResult, PlanSetupResult
2. Create `pkg/cli/spec/info.go` — feature path resolution, prerequisite validation
3. Port `common.sh` shared logic (repo root, branch detection, feature paths) into spec package

**Phase 2: `sl spec info` command**
1. Create `pkg/cli/commands/spec.go` with `info` subcommand
2. Implement `--json`, `--paths-only`, `--require-plan`, `--require-tasks`, `--include-tasks` flags
3. Verify JSON output matches `check-prerequisites.sh --json` exactly
4. Wire into `cmd/sl/main.go`

**Phase 3: `sl spec create` command**
1. Create `pkg/cli/spec/branch_name.go` — name generation, stop words, collision check
2. Create `pkg/cli/spec/create.go` — feature creation with git branch, spec dir, template
3. Add `create` subcommand to `pkg/cli/commands/spec.go`
4. Implement `--number`, `--short-name`, `--json` flags
5. Address [#46](https://github.com/specledger/specledger/issues/46): check remote branches for collision

**Phase 4: `sl spec setup-plan` command**
1. Create `pkg/cli/spec/plan_setup.go` — template copy logic
2. Add `setup-plan` subcommand to spec command
3. Verify JSON output matches `setup-plan.sh --json`

**Phase 5: `sl context update` command**
1. Create `pkg/cli/context/` package — plan parsing, agent file mappings
2. Create `pkg/cli/commands/context.go` with `update` subcommand
3. Port agent file template logic from `update-agent-context.sh`
4. Implement manual addition preservation (markers)
5. Support 17+ agent types

**Phase 6: Research spike — like-for-like bash→Go**
1. Document exact input/output contract for each bash script (done in research.md)
2. Create comparison tests: run bash script and Go command, diff outputs
3. Document gaps and edge cases discovered during porting

## `sl-comment` Skill Outline (High Level)

The `sl-comment` skill follows the same pattern as `sl-issue-tracking`:

```markdown
# sl-comment Skill

## When to Use
- When AI commands reference "review comments" or need to process feedback
- Triggered by: /specledger.clarify encountering open comments

## CLI Reference
- `sl comment list --status open --json` — get structured comment data
- `sl comment show <id>` — full comment with thread context
- `sl comment reply <id> --content "text"` — post detailed reply
- `sl comment resolve <id> --reason "text"` — resolve with reason

## Patterns
- Always use --json for structured output parsing
- Process comments individually (not bulk)
- Include file_path context when replying
- Thread replies reference parent comment context
```

## Clarify Integration (High Level)

Changes to `/specledger.clarify`:
1. **Step 2**: Replace `sl revise --summary` → `sl comment list --status open --json`
   - Agent receives compact overview (~20 tokens/comment): IDs, file paths, content previews, reply counts
   - Agent identifies which comments relate to spec ambiguities from previews
2. **Step 2b** (new): For comments the agent will process, drill down:
   - `sl comment show <id1> <id2> --json` — batch fetch full content + thread context
   - Agent now has complete feedback text and thread discussion for reasoning
3. **Comment processing**: After each clarification that addresses a comment:
   - `sl comment reply <id> --content "Addressed: <explanation>"`
   - `sl comment resolve <id> --reason "Resolved via clarify session"`
4. **Skill loading**: Reference to `sl comment` triggers `sl-comment` skill injection
5. **Backward compat**: If `sl comment` not available, skip silently (same as current `sl revise --summary` behavior)

**Token efficiency**: The two-level retrieval (list overview → show detail) means the agent only pays the full context cost for comments it actually processes. A spec with 25 comments costs ~500 tokens to scan, then ~200 tokens per comment drilled into, vs ~3000-5000 tokens for a verbose dump of all 25.

## Complexity Tracking

> No complexity violations identified. All work follows established patterns.

| Aspect | Approach | Justification |
|--------|----------|---------------|
| Comment package extraction | Move, don't copy | Avoids code duplication; revise imports from comment |
| PostgREST client shared | Single client in comment/ | Same auth, same query chain, same retry logic |
| Bash script like-for-like | Match JSON output exactly | AI command templates unchanged during migration |
| Agent context 17+ formats | Mapping table, not switch/case | Extensible without code changes |
